# 💥Operating System(Chapter 8 - Deadlocks)

> 대기 중인 스레드들이 결코 다시는 그 상태를 변경시킬 수 없으면 이런 상황을 **교착 상태**라 부른다.

---

### 시스템 모델

정상적인 작동 모드하에서, 프로세스는 다음 순서로만 자원을 사용할 수 있다.

1. 요청: 스레드는 자원을 요청한다. 요청이 즉시 허용되지 않으면(예를 들어, mutex 락을 다른 스레드가 가지고 있는 경우), 요청 스레드는 자원을 얻을 때까지 대기해야 한다.
2. 사용: 스레드는 자원에 대해 작업을 수행할 수 있다.(예를 들어, 자원이 mutex 락이라면, 스레드는 자신의 임계구역에 접근할 수 있다.)
3. 방출: 스레드가 자원을 방출한다.

한 스레드 집합 내의 모든 스레드가 그 집합 내의 다른 스레드에 의해서만 발생될 수 있는 이벤트를 기다린다면, 그 스레드 집합은 교착 상태에 있다. (ex. 식사하는 철학자 문제)

---

### 라이브락

교착 상태가 어떤 스레드 집합의 모든 스레드가 같은 집합에 속한 다른 스레드에 의해서만 발생할 수 있는 이벤트를 기다리면서 봉쇄되면 발생하는 반면에, 라이브락은 스레드가 실패한 행동을 계속해서 시도할 때 발생한다. 라이브락은 두 사람이 복도를 지나가려고 할 때 가끔 발생하는 현상과 유사하다. 한 사람은 오른쪽으로 움직이고 다른 한 사람은 왼쪽으로 움직이면서 여전히 서로의 진행을 방해한다. 그런 다음 한 사람은 왼쪽으로 이동하고 다른 한 사람은 오른쪽으로 움직인다. 봉쇄되지는 않았지만 앞으로 진행할 수 없다.

---

## 교착 상태 특성

### 필요조건

1. 상호 배제(mutual exclusion)
2. 점유하며 대기
3. 비선점
4. 순환 대기

이 4가지 조건이 모두 성립되어야만 교착 상태가 발생했다고 말할 수 있다.

---

### 교착 상태 처리 방법

원칙적으로 교착 상태 문제를 처리하는 데는 다음과 같은 3가지 다른 방법이 있다.

- 문제를 무시하고, 교착 상태가 시스템에서 절대 발생하지 않는 척한다.
- 시스템이 결코 교착 상태가 되지 않도록 보장하기 위해서 교착 상태를 예방하거나 회피하는 프로토콜을 사용한다.
- 시스템이 교착 상태가 되도록 허용한 다음에 복구시키는 방법이 있다.

첫 번째 해결한이 리눅스와 윈도우를 포함해 대부분의 운영체제가 사용하는 방법이다. 이렇다면 교착 상태를 처리하는 프로그램을 작성하는 것은 응용 개발자의 몫이며, 통상 두 번째 해결안에 개략적으로 설명된 접근법을 사용한다.

교착 상태를 탐지하고 복구하는 알고리즘이 없다면, 시스템은 교착 상태에 이를 수 있고, 그런데도 교착 상태가 발생한 것을 인식하지 못할 수 있다. 이 경우 탐지되지 않은 교착 상태는 수행할 수 없는 스레드에 의해 자원이 점유되어 있고, 그리고 많은 스레드들이 이러한 자원을 요청함에 따라 계속 교착 상태로 진입하기 때문에 시스템 성능을 저하하게 된다. 결국, 시스템은 작동을 정지하고, 수작업으로 다시 시작할 필요가 있다.

교착 상태를 무시하는 것이 다른 처리 방법과 비교해 비용이 적게 든다. 많은 시스템에서 교착 상태는 드물게 발생하기 때문에 다른 처리 방법을 사용하는 부가적인 비용은 그만한 가치가 없을 수 있다.

---

### 교착 상태 예방

4개의 조건이 모두 성립해야 교착 상태에 해당하므로, 교착 상태를 예방하기 위해서는 이들 조건 중에서 최소한 하나가 성립하지 않도록 보장하면 된다.

---

### 교착 상태로부터 회복

교착 상태를 깨뜨리는 데는 두 가지 방법이 있다. 한 가지 방법은 순환 대기를 깨뜨리기 위해 단순히 한 개 이상의 스레드를 중지시키는 것이다. 두 번째 방법은 교착 상태에 있는 하나 이상의 스레드들로부터 자원을 선점하는 것이다.

- 프로세스와 스레드의 종료

  > - 교착 상태 프로세스를 모두 중지 
  >
  >   > 이 방식은 확실하게 교착 상태의 사이클을 깨뜨리지만, 그 비용이 크다. 이들 프로세스가 오랫동안 연산했을 가능성이 있으며, 이들 부분 계산의 결과들을 반드시 폐기해야 하며, 아마도 후에 다시 계산해야하기 때문이다.
  >
  > - 교착 상태가 제거될 때까지 한 프로세스씩 중지
  >
  >   > 이 방법은 각 프로세스가 중지될 때마다 교착 상태 탐지 알고리즘을 호출해 프로세스들이 아직도 교착 상태에 있는지 확인해야 하므로 상당한 오버헤드를 유발한다.

- 자원 선점

  > 자원 선점을 이용해 교착 상태를 제거하려면, 교착 상태가 깨어질 때까지 프로세스로부터 자원을 계속 선점해 이들을 다른 프로세스에 주어야 한다.
  >
  > 만일 교착 상태를 해결하기 위해 선점이 필요하면, 다음의 세 가지 사항들을 고려해야 한다.
  >
  > 1. 희생자 선택
  > 2. 후퇴
  > 3. 기아상태