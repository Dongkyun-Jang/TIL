# 💫LCS(최장 공통 부분 수열), LIS(최장 증가 부분 수열)

---

> LCS(Longest Common Subsequence) - 연속적이지 않을 수 있으면서 가장 긴 부분 문자열
>
> LIS(Longest Increasing Subsequence) - 연속적이지 않을 수 있으면서 가장 긴 부분 수열



## LCS

---

최장 공통 부분 수열을 구하기 위해서는 2차원 배열이 필요하다.

'ACAYKP', 'CAPCAK' 이 경우를 예로 들어 설명하겠다. (이 두 문자열의 LCS는 'ACAK')

기본적으로 첫 행과 첫 열은 모두 '0'을 채워놓고 시작한다.(사용할 때 편의를 위해 경계를 두른다고 생각하면 좋다.)

|          | 0    | A    | C    | A    | Y    | K    | P    |
| -------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| <b>0</b> | 0    | 0    | 0    | 0    | 0    | 0    | 0    |
| <b>C</b> | 0    |      |      |      |      |      |      |
| <b>A</b> | 0    |      |      |      |      |      |      |
| <b>P</b> | 0    |      |      |      |      |      |      |
| <b>C</b> | 0    |      |      |      |      |      |      |
| <b>A</b> | 0    |      |      |      |      |      |      |
| <b>K</b> | 0    |      |      |      |      |      |      |

이 상태에서 좌측 상단에서 시작해서 우측 하단으로의 순회를 시작한다.

가장 큰 조건은 2가지 이다.

- 첫째!  **같은 문자가 나오면 대각선 값(좌측 상단) + 1 을 넣는다.** 왜냐하면 대각선까지의 값이 그 이전 알파벳까지의 비교값이 되기 때문이다.  `LCS[i][j] = LCS[i-1][j-1] + 1`

- 둘째!  **같은 문자가 아닌 경우 max(왼쪽값, 상단값)을 넣는다.**  `LCS[i][j] = Math.max(LCS[i][j - 1], LCS[i - 1][j])`

이 두 조건을 바탕으로 이런 식의 코드 작성이 가능해진다.

```javascript
const s1_len = s1.length
const s2_len = s2.length

let LCS = Array.from(Array(s1_len + 1), () => Array(s2_len + 1).fill(0))

for (let i = 1; i <= s1_len; i++) {
    for (let j = 1; j <= s2_len; j++) {
        if (s1[i - 1] == s2[j - 1]) {
            LCS[i][j] = LCS[i - 1][j - 1] + 1
            continue
        }
        LCS[i][j] = Math.max(LCS[i][j - 1], LCS[i - 1][j])
    }
}
```



이 코드를 거치게 되면 상단의 테이블을 이와 같이 변하게 된다.

|          |  0   |  A   |  C   |  A   |  Y   |  K   |  P   |
| :------: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| <b>0</b> |  0   |  0   |  0   |  0   |  0   |  0   |  0   |
| <b>C</b> |  0   |  0   |  1   |  1   |  1   |  1   |  1   |
| <b>A</b> |  0   |  1   |  1   |  2   |  2   |  2   |  2   |
| <b>P</b> |  0   |  1   |  1   |  2   |  2   |  2   |  3   |
| <b>C</b> |  0   |  1   |  2   |  2   |  2   |  2   |  3   |
| <b>A</b> |  0   |  1   |  2   |  3   |  3   |  3   |  3   |
| <b>K</b> |  0   |  1   |  2   |  3   |  3   |  4   |  4   |

이렇게 테이블을 완성하게 되면 `LCS[s1_len][s2_len]`의 값이 최장 공통 부분 수열의 길이임을 알 수 있다.

---

### 그렇다면 실제 최장 공통 부분 수열은 어떤 식으로 구할 수 있느냐?

위의 테이블을 채워나가는 순서를 고려해야 한다. 실제 최장 공통 부분 수열의 길이가 증가하는 순간 대각선으로 이동한다는 것을 알 수 있다. 때문에 이런 점들을 고려해서 실제 최장 공통 부분 수열을 구하기 위해서는 다음과 같은 코드가 필요하다.

```javascript
let i = s1_len
let j = s2_len

while (LCS[i][j] != 0) {
	
    //좌측->위->대각선순으로 나아간다.
    if (LCS[i][j] == LCS[i][j - 1])
        j--

    else if (LCS[i][j] == LCS[i - 1][j])
        i--

    else if (LCS[i][j] - 1 == LCS[i - 1][j - 1]) {
        ans += s1[i - 1]
        i--
        j--
    }
}
```

최대한 좌측으로 이동하고, 최대한 위로 이동한다. 그 이후에 대각선(좌측 상단)에 위치한 값과 현재 위치의 값의 차이가 1이라면 해당 알파벳을 추가해나가는 방식이다. 이 코드는 정확히 외우고 있는 것이 필요하다.

---

<br/>

<br/>

<br/>

## LIS

---

최장 증가 수열을 1차원의 배열이 필요하다.

만약 다음과 같은 배열이 있다고 가정하자.(표는 한 줄로 안 만들어지나보다.)

|                                    |                                    |                                    |      |      |                                    |      |                                    |                                    |
| :--------------------------------: | :--------------------------------: | :--------------------------------: | :--: | :--: | :--------------------------------: | :--: | :--------------------------------: | :--------------------------------: |
| <span style="color: red">10</span> | <span style="color: red">20</span> | <span style="color: red">40</span> |  25  |  20  | <span style="color: red">50</span> |  30  | <span style="color: red">70</span> | <span style="color: red">85</span> |

해당 배열의 빨간색 부분들이 LIS가 된다. 즉, 증가하는 순서대로 숫자를 고르면서 부분 수열의 길이가 최대 길이가 되도록 선택해 나가는 것이 LIS이다.

이러한, LIS 알고리즘을 풀 수 있는 방법은 총 3가지가 존재한다.

- 일반적인 dp - O(N^2)
- 세그먼트 트리를 활용 - O(NlogN)
- **이분 탐색을 활용하는 방법 - O(NlogN)**

일단 일반적인 dp의 경우 시간복잡도가 크기 때문에 실제로 사용하기 어렵다. 때문에 NlogN의 시간복잡도를 가지는 나머지 두가지 방법 중에 하나를 골라야 하는데, 지금의 시점에서 내가 이해하기 편한 이분 탐색을 활용하는 법을 선택하겠다.

 이분 탐색을 활용하는 방법은 크게 2가지의 규칙을 가진다.

- 기존 배열의 순회하며 다른 배열에 값을 넣어가면서 진행한다.
- 다른 배열의 마지막 값보다 현재 기존 배열의 값이 크다면 그냥 맨 뒤에 삽입, 작거나 같다면 lower_bound를 통한 이분탐색을 통해 구한 인덱스에 현재 기존 배열의 값을 넣는다.

---

## lower_bound가 무엇이냐???

> lower_bound란 key값을 찾으려 할 때 만약 key값이 있다면 그래도 key값을 가져오고, key값이 존재하지 않는다면 **key값보다 큰 가장 작은 정수 값을 찾는다.** 

```javascript
function lower_bound(arr, n, key) {
    let start = 0
    let end = n
    while (start < end) {
        mid = parseInt((start + end) / 2)

        if (arr[mid] < key) {
            start = mid + 1
        }
        else {
            end = mid
        }
    }
    return end
}
```

이 함수를 통해 lower_bound에 해당하는 인덱스를 얻어낼 수 있다.

<br/>

## 그렇다면 반대로 upper_bound는???

> **(같은 값이 아닌) key 값을 초과하는 가장 첫번째 원소의 위치를 구하는 함수이다.**

```javascript
function upper_bound(arr, n, key) {
    let start = 0
    let end = n
    while (start < end) {
        mid = parseInt((start + end) / 2)

        if (arr[mid] <= key) {
            start = mid + 1
        }
        else {
            end = mid
        }
    }
    return end
}
```

이 함수를 통해 upper_bound에 해당하는 인덱스를 얻어낼 수 있다.

<br/>

**이 두 함수 모두 이진탐색(Binary Search)에 기반하기 때문에 반드시 정렬된 상태의 배열에서만 사용 가능하다.**

---

단순히 글로만은 이해가 어렵기 때문에 그림을 통해 설명한다.(파란색은 진행상황을 나타낸다.)

---

| <span style="color: blue">10</span> | <span style="color: blue">20</span> | <span style="color: blue">40</span> |  25  |  20  |  50  |  30  |  70  |  85  |
| :---------------------------------: | :---------------------------------: | :---------------------------------: | :--: | :--: | :--: | :--: | :--: | :--: |
|                 10                  |                 20                  |                 40                  |      |      |      |      |      |      |

1) 10, 20, 40까지는 증가하는 배열이기 때문에 그대로 넣는다.

<br/>

| <span style="color: blue">10</span> | <span style="color: blue">20</span> |  <span style="color: blue">40</span>   | <span style="color: blue">25</span> |  20  |  50  |  30  |  70  |  85  |
| :---------------------------------: | :---------------------------------: | :------------------------------------: | :---------------------------------: | :--: | :--: | :--: | :--: | :--: |
|                 10                  |                 20                  | <span style="color: skyblue">25</span> |                                     |      |      |      |      |      |

2) 25의 경우, 아래 배열의 맨 마지막 값인 40보다 작다. 때문에 lower_bound 탐색을 한 번 거친다.(25와 같거나, 25와 같은 값이 없는 경우 25보다 큰 가장 작은 값을 찾는다.) => 40이 나온다. 때문에 40을 삭제하고 그 자리에 25를 넣는다.

<br/>

| <span style="color: blue">10</span> |  <span style="color: blue">20</span>   | <span style="color: blue">40</span> | <span style="color: blue">25</span> | <span style="color: blue">20</span> |  50  |  30  |  70  |  85  |
| :---------------------------------: | :------------------------------------: | :---------------------------------: | :---------------------------------: | :---------------------------------: | :--: | :--: | :--: | :--: |
|                 10                  | <span style="color: skyblue">20</span> |                 25                  |                                     |                                     |      |      |      |      |

3) 20의 경우, 아래 배열의 맨 마지막 값인 25보다 작다. 때문에 lower_bound 탐색을 한 번 거친다.(20과 같거나, 20과 같은 값이 없는 경우 20보다 큰 가장 작은 값을 찾는다.) => 20이 나온다. 때문에 20을 삭제하고 그 자리에 20을 넣는다.

<br/>

| <span style="color: blue">10</span> | <span style="color: blue">20</span> | <span style="color: blue">40</span> |  <span style="color: blue">25</span>   | <span style="color: blue">20</span> | <span style="color: blue">50</span> |  30  |  70  |  85  |
| :---------------------------------: | :---------------------------------: | :---------------------------------: | :------------------------------------: | :---------------------------------: | :---------------------------------: | :--: | :--: | :--: |
|                 10                  |                 20                  |                 25                  | <span style="color: skyblue">50</span> |                                     |                                     |      |      |      |

4) 50의 경우, 25보다 크기 때문에 그냥 맨 뒤에 넣는다.

<br/>

| <span style="color: blue">10</span> | <span style="color: blue">20</span> | <span style="color: blue">40</span> |  <span style="color: blue">25</span>   | <span style="color: blue">20</span> | <span style="color: blue">50</span> | <span style="color: blue">30</span> |  70  |  85  |
| :---------------------------------: | :---------------------------------: | :---------------------------------: | :------------------------------------: | :---------------------------------: | :---------------------------------: | :---------------------------------: | :--: | :--: |
|                 10                  |                 20                  |                 25                  | <span style="color: skyblue">30</span> |                                     |                                     |                                     |      |      |

5) 30의 경우, 아래 배열의 맨 마지막 값인 50보다 작다. 때문에 lower_bound 탐색을 한 번 거친다.(30과 같거나, 30과 같은 값이 없는 경우 30보다 큰 가장 작은 값을 찾는다.) => 50이 나온다. 때문에 50을 삭제하고 그 자리에 30을 넣는다.

<br/>

| <span style="color: blue">10</span> | <span style="color: blue">20</span> | <span style="color: blue">40</span> | <span style="color: blue">25</span> |  <span style="color: blue">20</span>   |  <span style="color: blue">50</span>   | <span style="color: blue">30</span> | <span style="color: blue">70</span> | <span style="color: blue">85</span> |
| :---------------------------------: | :---------------------------------: | :---------------------------------: | :---------------------------------: | :------------------------------------: | :------------------------------------: | :---------------------------------: | :---------------------------------: | :---------------------------------: |
|                 10                  |                 20                  |                 25                  |                 30                  | <span style="color: skyblue">70</span> | <span style="color: skyblue">85</span> |                                     |                                     |                                     |

6) 70, 85은 아래 배열의 맨 마지막보다 크기 때문에 그대로 넣는다.

---

### 이 과정을 거치면 최장 증가 수열의 길이인 `6`을 얻을 수 있게 된다.

코드는 다음과 같다.

```javascript
function LIS() {
    let idx = 0
    cache[idx] = arr[0]

    for (let i = 1; i < N; i++) {

        if (cache[idx] < arr[i]) {
            cache[++idx] = arr[i]
            continue
        }
        let idx2 = lower_bound(cache, idx, arr[i])
        cache[idx2] = arr[i]
    }
    return idx + 1
}
```

---

하지만, 이런 LIS 함수는 굉장히 큰 단점이 존재한다.

## 최장 증가 수열의 길이는 보장할 수 있지만 이를 통해 만들어지는 실제 최장 증가 수열은 보장되지 않는다는 것이다.

실제 최장 증가 수열을 구해내기 위해서는 더 까다로운 코드가 필요하고 어려운 알고리즘이다...