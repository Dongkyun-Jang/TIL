# 😍콜백 함수의 단점과 프로미스를 사용하는 이유

> 콜백 함수의 가장 큰 단점은 제어의 역전과 콜백헬 문제이다. 이런 문제들을 해결하기 위해 프로미스가 등장하였다.

---

콜백 함수의 특징에 대해 먼저 알아볼 필요가 있다.

- 콜백 함수는 다른 코드에 인자로 넘겨줌으로써 그 제어권도 함께 위임한 함수이다.
- 제어권을 넘겨받은 코드는 다음과 같은 제어권을 가진다.
  - 콜백 함수를 호출하는 시점을 스스로 판단해서 실행한다.
  - 콜백 함수를 호출할 때 인자로 넘겨줄 값들 및 그 순서가 정해져 있다. 이 순서를 따르지 않고 코드를 작성하면 엉뚱한 결과가 나온다.
  - 콜백 함수의 this가 무엇을 바라보도록 할지 졍해져 있는 경우가 존재한다. (정해지지 않은 경우에는 전역 객체를 바라본다.) 사용자가 임의로 this를 바꾸고 싶다면 bind 메서드를 활용하면 된다.
- 어떤 함수에 인자로 메서드를 전달하더라도 이는 결국 함수로서 실행된다.
- 비동기 제어를 위해 콜백 함수를 사용하다 보면 콜백 지옥에 빠지기 쉽다. 이 때문에 콜백 지옥에서 벗어날 수 있는 훌륭한 방법들이 등장하고 있는데, 이것이 Promise, Generator, async/await 이다.

결국 콜백 함수를 딱 한 줄로 정의하자면, **다른 함수 또는 메서드에게 인자로 넘겨줌으로써 그 제어권도 함께 위임한 함수이다.** 콜백 함수를 위임받은 코드는 자체적인 내부 로직에 의해 이 콜백 함수를 적절한 시점에 실행한다.

제어권 위임, 적절한 시점.... 애매모호하면서도 위험해 보이는 단어이다.

즉, 콜백 함수의 제어권 위임과 적절한 시점에 호출되는 특징들로 인해 심각한 문제가 발생할 수 있는데 이를 **제어의 역전**이라 한다.

 제어의 역전은 콜백 함수의 **순차성**과 **믿음성**을 결여 시킨다. 콜백 함수를 다른 곳으로 전달하면서 이에 대한 제어권도 같이 넘기게 되면, 콜백 함수가 어떻게 진행되고 있는지 우리가 알 방법이 없고 때문에 그저 무사히 잘 실행되기를 기도하는 수밖에 없다.

이 제어의 역전으로 인해 일어날 수 있는 문제들은 다음과 같다.

- 너무 일찍 콜백 함수를 호출
- 너무 늦게 콜백 함수를 호출
- 너무 적게, 아니면 너무 많이 콜백을 호출
- 필요한 환경/인자를 정상적으로 콜백에 전달 못함
- 발생 가능한 에러/예외를 무시함

프로미스는 이런 콜백 함수의 문제점을 해결하기 위해 등장하였다.

---

### Promise

프로미스를 간단하게 정의하자면 "내용은 실행되었지만 결과를 아직 반환하지 않은 객체" 이다.

`then()`을 붙이면 결과를 반환하고, 실행이 완료되지 않았다면 완료된 이후에 `then()`에 결과를 반환한다.

```javascript
// ZeroCho TV의 Promise 강의에서 제공하는 예시입니다.

const condition = true

const promise = new Promise((resolve, reject) => {
	if(condition){
		resolve('성공')
	}
	else{
		reject('실패')
	}
})

// 위의 Promise가 실행되면서 promise에는 resolve 혹은 reject가 저장되어 있을 것이지만, 아직 반환은 하지 않은 상태이다.

// promise에 resolve가 있다면 then으로 연결되고, promise에 reject가 있다면 catch로 연결된다.
promise
	.then((message)=>{
		console.log(message)
	})
	.catch((err)=>{
		console.log(err)
	})
```

```javascript
// Promise.resolve() : 바로 resolve를 반환하는 프로미스
// Promise.reject()  : 바로 reject를 반환하는 프로미스

const promise1 = Promise.resolve('성공1')
const promise2 = Promise.resolve('성공2')

// Promise.all로 여러 개의 프로미스 결과들을 한번에 반환할 수 있다.
Promise.all([promise1, promise2])
	.then((result)=>{
		console.log(result)     // ['성공1', '성공2']
	})
```



이런 프로미스가 어떻게 제어의 역전으로 만들어지는 문제들을 해결하는지 확인해보자.

---

- 너무 일찍 혹은 너무 늦게 콜백 함수를 실행한다는 문제

  > 프로미스의 설계상 콜백 함수의 실행 시점은 실행이 완료되고 난 이후 `then()` 혹은 `catch()` 를 만났을 때이다. 이 말은 결국 `then()`과 `catch()`의 위치를 조절해서 콜백 함수의 실행 시점을 내 마음대로 정할 수 있다는 것이다. 즉, 제어권을 넘기지 않는 것이다.

- 너무 적게 혹은 너무 많이 호출할 수도 있다는 문제

  > 프로미스에서 콜백 함수는 정의상 단 한번만 호출된다. 여러 차례 호출하려고 하는 경우 최초의 요청만 처리하고 이후의 시도는 무시한다.

정리하자면 프로미스가 콜백을 대체하는 것이 아니다. 다만, 프로미스로 콜백을 다루면 콜백 자체의 단점들을 상쇄할 수 있다는 것이다. 때문에 우리는 프로미스를 써야 한다.

---

### 🔴Micro Task Queue

지난 번에 이벤트 루프에 대한 내용을 정리하면서 비동기 함수들에 대한 처리는 Web API에서 이루어지고, Web API에서의 처리가 끝나면 Task Queue로 들어간다고 학습하였다. 

그렇다면 콜백 함수, 프로미스 모두 비동기 함수인데 Web API에서의 처리 이후 같은 Task Queue에 들어가는건가?? 라는 의문을 가질 수 있다.

정답을 설명하기 전에 코드의 흐름을 먼저 보고 넘어갈 필요가 있다.

```javascript
setTimeout(function() { // (A)
    console.log('A');
}, 0);
Promise.resolve().then(function() { // (B)
    console.log('B');
}).then(function() { // (C)
    console.log('C');
});
```

콘솔에 찍히는 순서는 어떻게 될까? 프로미스도 비동기로 실행된다고 할 수 있으니 Task Queue에 추가돼서 순서대로 `A -> B -> C` 가 되는 것일까?

정답은 `B -> C -> A` 이다. 이유는 프로미스가 마이크로 테스트 큐를 사용하기 때문이다. 마이크로 태스크 큐는 일반 태스크 큐보다 더 높은 우선순위를 갖는다. 즉, 태스크 큐에 대기 중인 태스크가 있더라도 마이크로 태스크 큐 속에 있는 마이크로 태스크가 먼저 실행된다. 

조금 더 자세한 내용은 이 [NHN 기술포스트](https://meetup.toast.com/posts/89)를 참고할 필요가 있다.

---

### 참고문헌

코어 자바스크립트(정재승 지음)

https://devowen.com/286?category=721812

https://www.youtube.com/watch?v=NEaDPHNflGI

https://meetup.toast.com/posts/89