

# 💥정규표현식

> 문자열 문제들을 풀다보면 정규표현식이 필요해지는 순간들이 생긴다. 뿐만아니라 추후에 자바스크립트를 통해 프로젝트를 진행할 때에도 정규표현식을 활용해 검증 절차를 거치는 경우가 종종 존재한다. 이런 이유들 때문에 정규표현식에 대한 공부가 필요하다는 생각이 들었고 이렇게 정리하게 되었다.
>
> *정규 표현식을 통달하는 과정에서 구문을 익히는 것은 가장 쉬운 부분임을 알아야 한다. 진정한 도전 과제는 그 구문을 어떻게 적용할 것인지, 주어진 문제를 어떻게 분해해야 정규표현식으로 해결할 수 있는지 익히는 것이다. - 『손에 잡히는 정규표현식 p.5』* 
>
> ^ 띵언이다 명심하자.
>
> 참고한 자료는 총 3가지이다.
>
> - 

---

### 정규 표현식을 선언하는 2가지 방법

- `let re = new RegExp("pattern", "flags")` - ('긴' 문법)
- `let re = /pattern/flag` - ('짧은' 문법)

두 개의 방법 중 편한 것을 골라서 사용하면 된다. 하지만, 변수에 저장된 문자열을 pattern으로 사용해야 하는 경우에는 반드시 `RegExp`를 사용하여야 한다.

```javascript
//백준 1543 문서검색

const chkStr = input()
const cmpStr = input()

//입력으로 받는 cmpStr을 pattern으로 사용하여야 한다. 이 경우 반드시 긴 문법을 사용한다. 
const re = new RegExp(cmpStr, "g")
let tmp = chkStr.match(re)
console.log((tmp !== null) ? tmp.length : 0)
```

---

### 플래그

> 자바스크립트에는 6가지의 플래그가 존재하지만, 실질적으로 내가 쓰게 될 플래그는 3개 뿐이라고 생각한다. 때문에 3개의 플래그에 대해서만 정리할 예정이고 추후에 다른 플래그를 알아야 할 때 https://ko.javascript.info/regexp-introduction 이곳에 와서 확인하면 되겠다.

- i

  > i 플래그가 붙으면 대소문자의 구분없이 검색한다. (A와 a에 차이가 없게 된다.)

- g

  > g 플래그가 붙으면 패턴과 일치하는 모든 것들을 찾는다. g 플래그가 없으면 패턴과 일치하는 첫번째 결과만을 반환한다.

- m

  > 다중 행 모드를 활성화한다. 여러 줄에서 똑같은 검색을 할 수 있게 된다.

---

### 문자 플래그

- `\d`

  > 숫자(0-9)를 선택한다.

- `\s`

  > 스페이스, 탭(\t), 개행(\n)과 같은 공백 기호들을 선택한다.

- `\w`

  > 모든 문자를 선택한다. 여기서 문자란 대문자(A-Z), 소문자(a-z), 숫자(0-9) 그리고 밑줄(_)을 포함한다.

- `\D`

> 숫자가 아닌 모든 것들이 선택된다. 스페이스, 탭(\t), 개행(\n)같은 것들까지 모두 선택된다.

- `\S`

  > `\s`에서 선택되는 것들 빼고 모두

- `\W`

  > `\w`에서 선택되는 것들 빼고 모두

- .

  > 온점은 줄 바꿈 문자를 제외한 모든 문자와 일치한다. `/./`

  **만약 온전히 온점, 물음표 같은 특수문자들을 선택하고 싶다면 해당 특수문자 앞에 백슬래쉬를 붙이면 된다.**

---

### 앵커 플래그

- `^`

  > `^`는 문장의 시작을 의미한다. `/^Ya/`와 같은 패턴은 문장의 시작이 Ya인 것만 찾게 된다.

- `$`

  > `$`는 문장의 끝을 의미한다.

이 두 종류의 앵커 플래그를 활용하여 완전히 일치하는 문자열들을 찾을 수도 있다.

![regExp1](/assets/img/regExp1.png)



![regExp2](/assets/img/regExp2.png)



이 두개의 경우를 통해 앵커 플래그를 붙였을 때와 붙이지 않았을 때를 정확하게 구분할 수 있다.

---

### SET

- |  => 또는
- ()  => 그룹
- []  => 문자셋, 괄호 안의 어떤 문자든 **딱 한 개만 선탁한다**
- [^]  => 부정 문자셋, 괄호 안의 어떤 문자가 아닐 때
- (?:)  => 찾지만 기억하지 않음
- ?  => 있거나 없거나(0개 혹은 1개)
- \*  => 없거나 있거나 많거나(0개 이상 있는 경우)
- \+  => 한 개 있거나 많거나(1개 이상 있는 경우)
- {n}  => n번 반복
- {min,}  => 최소 min번 반복
- {min, max}  => min 이상, max 이하 개수만큼 반복

```javascript
/gr(e|a)y/
//=> grey와 gray를 찾게 된다. 하지만, 이 두 개가 하나의 그룹으로 지정된다.

/gr(?:e|a)y/
//=> grey와 gray를 찾게 된다. 또한, 하나의 그룹으로 지정되지 않는다. 하지만, 보기가 힘들다. 때문에 보통 똑같은 기능을 하지만 간단한 대괄호를 많이 사용한다.

/gr[ea]y/
//=> grey와 gray를 찾는다.

/gr[a-f]y/
//=> gray, grby, grcy, grdy, grey, grfy
   
/[a-zA-Z0-9]/
//=> 이렇게 하면 특수기호를 제외한 모든 문자를 딱 한 개 선택할 수 있다.
  
/[^a-zA-Z0-9]/
//=> 이렇게 하면 특수기호 딱 한 개를 선택하게 된다.
    
/gra?y/
//=> gry와 gray를 찾는다.

/gra*y/
//=> gry, gray, graay, graaay, graaaay, ...
    
/gra+y/
//=> gray, graay, graaay, graaaay, ...

/gra{2}y/
//=> graay를 찾는다.
    
/gra{2, 4}y/
//=> graay, graaay, graaaay를 찾는다.

/gra{2,}y/
//=> graay, graaay ...
```

---

`\b [Cc] [Aa] [Rr] \b`과 같이 코드를 작성하면 대소문자 구분없이 경계의 car를 선택할 수 있다.

> 경계를 선택할 수 있다는 것은 `\b cat \b` 를 통해 `cat`은 선택할 수 있지만 `scattered` 속 `cat`은 선택할 수 없음을 의미한다.

물론, `^[Cc] [Aa] [Rr] $` 이 두 종류의 앵커 플래그를 활용하여도 똑같은 결과물을 도출해낼 수 있다.

하지만, 이 경우 `\b` 를 사용하는 것이 맞는 방법이다.

이 두 가지를 구분하는 구분점은 단어를 경계로 하냐, 문장을 경계로 하냐이다.

단어의 경계를 기반으로 단어를 찾을 때는 `\b - \b` 를 쓰지만,

문장의 경계를 기반으로 문장을 찾을 때는 `^ - $` 를 사용한다.

이 예제의 경우 `car`이라는 하나의 단어만을 찾는 상황이기 때문에 `\b`를 사용하는 것이 맞다.

만약, `car is empty` 와 같이 문장을 찾아야 하는 경우에는 앵커 플래그를 통해 찾으면 된다.

---

부분적으로만 대소문자를 구분하지 않을 때는 [Rr]eg[Ee]x 와 같은 모양으로 표현할 수도 있다.

---

`[A-z]` 로 표현하면 아스키문자 `A`와 아스키문자 `z` 사이에 있는 모든 문자와 일치한다. 하지만, 이런 모양은 사용해서는 안된다. `Z-a` 사이에 몇몇 특수기호들이 들어가 있기 때문에 실수로 해당 특수기호들까지 선택되어버려질 수도 있다.

---

대괄호([]) 안에 캐럿(^) 기호를 넣게 되면 해당 문자나 범위를 제외할 수 있다.

---

대괄호, 캐럿과 같은 메타 문자들을 그대로 가져오기 위해서는 해당 메타 문자 앞에 백슬래쉬(\)를 넣어야 한다.

---

마침표(.)는 어떠한 문자와도 일치한다.(줄바꿈 문자만 빼고)

---

`\r\n` (캐리지 리턴 + 개행) 은 줄의 끝을 나타내는데 사용한다.

`\r\n\r\n` 하면 줄의 끝이 연속해서 두 번 나오는 부분! 즉, 두 레코드 사이의 빈 줄을 선택하게 된다.

하지만, 여기에는 문제가 있는데 Unix, Linux 환경에서는 `\r`은 제외하고 `\n`만을 사용한다. 때문에, `\n` 앞에 `\r`이 있을 경우에만 일치시키는 것이 이상적이다.

=> [\r] ? \n [\r] ? \n 	//[\r] 이 있어도 되고 없어도 됨을 물음표(?)를 통해 나타냈다.

---

### 탐욕적 수량자 vs 게으른 수량자

<br/>

만약, `b tag`와 `b tag`로 둘러쌓인 내용을 파악해야할 때 우리는 아마도 `<[Bb]>.*</[Bb]>` 이런 모양의 정규표현식을 작성할 것이다.

 하지만, 이런 정규표현식을 우리의 의도와는 다른 결과물을 도출시킨다.

![greedy quantifier](/assets/img/greedy_quantifier.jpg)

기본적으로 `quantifier`는 그리디하기 때문이다! 최대한 길게 결과물을 도출시키려는 특성이 있기 때문에 사진처럼 우리의 의도와는 다르게 문자열을 파싱한다.

그렇다면 원래 의도에 맞게 문자열을 파싱하기 위해서는 어떤 식의 `quantifier`가 필요할까? 바로 그리디 하지 않은 `lazy quantifier`가 필요하다. 이 둘의 코드 상의 차이는 딱 물음표(?) 한 개의 차이이다.

![lazy quantifier](/assets/img/lazy_quantifier.jpg)

| 탐욕적 수량자 | 게으른 수량자 |
| :-----------: | :-----------: |
|       *       |      *?       |
|       +       |      +?       |
|     {n,}      |     {n,}?     |

---

문자열 그룹이 반복돼야하는 경우에는 소괄호를 통해 하위표현식으로 묶으면 된다.

`(&nbsp;){2,}`와 같은 정규표현식으로 `&nbsp;&nbsp;`혹은 2개 이상의 반복을 선택할 수 있다.

IP 주소 선택을 위한 `\d{1, 3} \. \d{1, 3} \. \d{1, 3}`은 `(\d{1, 3} \.){2} \d{1, 3}`으로 대체할 수 있다.

물론! 통일성을 주겠다고 `(\d{1, 3} \.){2} (\d{1, 3})` 이런 식으로 표현할 수도 있다. 이렇게 해도 동일하게 동작은 하지만, 그룹으로 묶지 않아도 되는 것을 묶게 되면 성능상의 단점을 가지게 될 수 있다.

---

### 전방탐색 vs 후방탐색

- (?=) 긍정형 전방탐색
- (?!) 부정형 전방탐색
- (?<=) 긍정형 후방탐색
- (?<!) 부정형 후방탐색



Q. `:`을 기준으로 전방을 탐색하고 싶다! (기준이 되는 `:`은 선택X)

