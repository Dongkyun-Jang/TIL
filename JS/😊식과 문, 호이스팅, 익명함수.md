

# 😊식과 문, 호이스팅, 익명함수

---

가장 먼저 식과 문을 구분해야 한다. 

식과 문을 구분하는 가장 큰 외관상의 차이는 세미 콜론(;)의 유무이다. 식의 마무리는 반드시 세미 콜론이어야하는 반면 문의 마무리에서는 세미 콜론을 사용하지 않는다. 문은 대표적으로 `if`와 `while` 같은 것들이 있다.

자바스크립트의 함수도 문과 식이 따로 존재한다. 바로 함수 선언문과 함수 표현식이다.

```javascript
// 함수 선언문
function foo(a, b) {
	return a + b
}

// 함수 표현식(익명 함수를 사용한 경우)
let foo = function(a, b) {
	return a + b
}

//함수 표현식(기명 함수를 사용한 경우)
let foo = function tmp(a, b) {
    return a + b
}
```

"식의 마무리는 반드시 세미 콜론이어야 한다고 해놓고 왜 아래의 함수 표현식에는 세미 콜론이 없는거죠?" 라는 질문이 제기 될 수 있다.

자바스크립트는 이미 알다시피 세미 콜론을 사용해도되고, 사용하지 않아도 된다.(사용하지 않는 것을 추천한다.) 프로그래머에게 이러한 선택지가 부여될 수 있는 이유는 자바스크립트 엔진이 알아서 세미 콜론이 필요한 곳에 넣어주기 때문이다. (이러한 개념은 ASI(Automatic Semicolon Insertion) 이라고 한다.) 때문에 위 코드를 실행시키게 되면 함수 선언문의 경우에는 달라지지 않지만, 함수 표현식의 경우 ASI에 의해 자동으로 맨 마지막에 세미 콜론이 추가될 것이다.

식과 문을 구분해야하는 가장 큰 이유는 함수 호이스팅에 있다.

```javascript
foo(2, 3) // 5

function foo(a, b) {
	return a + b
}
```

함수 선언문의 경우 이렇게 함수 정의 이전에 호출해서 사용이 가능하다. 

반면 함수 표현식의 경우 이와 같은 호이스팅이 불가능하다. 

---

조금 더 명확한 설명을 위해 변수 호이스팅부터 간단히 설명하겠다.

먼저, var의 경우 변수 호이스팅이 가능하다. 하지만, 이때 호이스팅 되는 대상은 할당이 없는 선언 뿐이다. 

```javascript
x            // undefined(호이스팅되어서 선언은 존재한다. 하지만, 할당은 되지 않았기 때문에 undefined가 나온다.)
var x = 3
x            // 3


// 실제 코드로 동작을 설명하자면 다음과 같다.
var x       // 선언만이 호이스팅 되었음을 보여준다.
x
x = 3
x
```

반면, let과 const는 호이스팅이 불가능하다.

```javascript
x         // ReferenceError: x는 정의되지 않았습니다.
let x = 3 // 위에서 에러가 났기 때문에 여기까지 못 온다.
```

---

이 차이를 인지하고 함수 표현식에서 함수 호이스팅을 시도할 때 어떤 에러가 나는지를 확인한다.

```javascript
foo()     // TypeError: expression is not a function.

var foo = function(a, b) {
	return a + b
}
```

```javascript
foo()    // ReferenceError: foo는 정의되지 않았습니다. (아래 foo에 대입되는 함수가 기명이어도 결과는 같다.)

const foo = function(a, b) {
	return a + b
}
```

이 차이를 이해해야 한다. var의 경우 변수 선언만이 호이스팅 될 수 있다. 때문에 foo는 호이스팅 될 수 있지만 타입은 var이다. var 타입의 변수를 함수 호출 했기 때문에 함수가 아니라는 타입 에러가 나온다.

const의 경우 아예 변수 호이스팅부터가 불가능하다. 때문에 ReferenceError가 도출된다.

### 그렇다면 왜!!! 함수 선언문은 호이스팅 되는데 함수 표현식은 호이스팅되지 않는가???

이 이유를 정확하게 설명하기 위해서는 **실행 컨텍스트**를 제대로 이해해야 한다. 나 또한 아직 정확하게 이해하지 못하였고 공부 중이다. 하지만, 간단하게는 이 질문에 대해 대답할 수 있다.

실행 컨텍스트를 구성할 때 함수는 함수 전체를 기록하게 된다. 반면, 변수는 그 선언만을 기록해둔다. 때문에, 함수 선언문은 자바스크립트 엔진이 함수로 판단하고 전체를 기록하는 반면, 함수 표현식은 변수로 판단하고 변수의 선언만을 기록하게된다.

## 요약

- 함수는 값이다. 따라서 함수는 값처럼 할당, 복사, 선언될 수 있다.
- **함수 선언문 방식으로 함수를 생성하면, 함수가 독립된 구문 형태로 존재하게 된다.**
- **함수 표현식 방식으로 함수를 생성하면, 함수가 표현식의 일부로 존재하게 된다.**
- **함수 선언문은 코드 블록이 실행되기도 전에 처리된다. 따라서 블록 내 어디서든 활용 가능해진다.**
- **함수 표현식은 실행 흐름이 표현식에 다다랐을 때 만들어진다.**

---

이렇게 식과 문을 구분한 이유가 호이스팅 때문만은 아니다. 익명함수에 대해 이해하기 위해서도 식과 문의 분리가 필요하다.

이렇게 식과 문을 구분한 이유는 익명함수를 식에서만 사용할 수 있기 때문이다. (기명함수의 경우에는 문과 식 모두에서 사용이 가능하다.)

익명 함수를 사용하는 경우는 크게 두 가지로 볼 수 있다.

- 변수에 함수를 저장해야 할 때 (변수가 함수이기 때문에, 함수는 파라미터가 될 수도, return 값이 될 수도 있다. )
- 즉시 호출 함수(IIFE)를 사용할 때

변수에 함수를 저장하는 경우는 워낙 많이 봤고, 즉시 호출 함수에 대해서는 파일을 분리해서 작성할 예정이다.

---

## 마무리

이렇게 하나의 파일로 익명함수를 설명한 이유는 이후에 화살표 함수에 대해 설명하기 위해서이다. 먼저, 기본적으로 화살표 함수는 익명 함수로만 사용이 가능하다. 익명 함수는 함수 표현식에서만 사용이 가능하다. 때문에, 자연스럽게 우리는 화살표 함수는 함수 표현식으로 작성된다는 것을 알 수 있다. 

그렇다고 해서, 화살표 함수가 함수 표현식을 대체하기 위해 만들어진 것은 아니다.

화살표 함수에는 훨씬 더 다양한 특징들이 있고, 이에 대한 내용은 빠른 시일 내에 작성하겠다.

+const, let, var의 저장방식이 어떤 차이가 있길래 스코프가 달라지는 지에 대해서도 찾아봐야겠다. 아마도 실행 컨텍스트와 관련이 있을 것 같은데...

---

## 참고문헌

https://velog.io/@doodream/%EC%BD%94%EC%96%B4-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-02.-%EC%8B%A4%ED%96%89-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8

https://www.zerocho.com/category/JavaScript/post/5741d96d094da4986bc950a0

https://velog.io/@seob/%EC%8B%A4%ED%96%89-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8Execution-Context-3-%ED%95%A8%EC%88%98-%EC%84%A0%EC%96%B8%EB%AC%B8%EA%B3%BC-%ED%95%A8%EC%88%98-%ED%91%9C%ED%98%84%EC%8B%9D

